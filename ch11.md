# 轻量函数式编程
# 第 11 章：融会贯通

现在你已经掌握了所有需要掌握的关于轻量函数式编程的内容。下面不会再引入新的概念。

在最后一章中，我们的目标是把概念融会贯通起来。我们将运用我们所学到的知识，把书中的概念结合起来。本章中的代码解释了在 JavaScript 中运用「轻量函数式编程」时，如何做到既实用又符合规范。

以后你将会经常的用到这些技巧，而理解本章的内容将对你在实际项目中运用函数式编程有极大的帮助。

## 准备

我们来写一个简单的股票行情工具吧。

**注意：** 作为参考，完整的代码在 `ch11-code/` 子目录下，可以在本书的 GitHub 仓库（[https://github.com/getify/Functional-Light-JS](https://github.com/getify/Functional-Light-JS)）下找到。同时，在书中讨论到的函数式编程辅助函数的基础上，我们筛选了所需的一部分放到了 `ch11-code/fp-helpers.js` 文件中。本章中，我们只会讨论到其中相关的部分。

首先，我们写工具的 HTML 部分，这样就可以有地方展示信息了。我们在 `ch11-code/index.html` 文件中先写一个空的 `<ul ..>` 元素，但是在运行时，DOM 会被填充成：

```html
<ul id="stock-ticker">
	<li class="stock" data-stock-id="AAPL">
		<span class="stock-name">AAPL</span>
		<span class="stock-price">$121.95</span>
		<span class="stock-change">+0.01</span>
	</li>
	<li class="stock" data-stock-id="MSFT">
		<span class="stock-name">MSFT</span>
		<span class="stock-price">$65.78</span>
		<span class="stock-change">+1.51</span>
	</li>
	<li class="stock" data-stock-id="GOOG">
		<span class="stock-name">GOOG</span>
		<span class="stock-price">$821.31</span>
		<span class="stock-change">-8.84</span>
	</li>
</ul>
```

在继续下去之前，我要提醒一下，操作 DOM 是 I/O，所以这是副作用。我们不能消除这些副作用，但是我们可以减少它们。我们尽量减少和 DOM 相关的操作。这些减少副作用的技巧在第 5 章中已经提到了。

概括一下我们的小工具的功能：代码将在每次添加新股票事件「收到」时添加 `<li ..>` 元素，并在股票价格更新事件发生时更新价格。

在第 11 章的示例代码 `ch11-code/mock-server.js` 中，我们设置了一些定时器，把随机生成的假股票数据推送到一个简单的事件发送器中，来模拟从服务器收到的股票数据。我们暴露了一个 `connectToServer()` 接口来实现模拟，但是实际上，它只是返回了一个假的事件发送器。

**注意：** 这个文件是用来模拟的，所以我没有花费太多的精力让它非常符合函数式编程。不建议大家花太多时间研究这个文件中的代码。如果你写了一个真正的服务器 —— 对于有雄心勃勃的读者来说，这是一个非常有趣的和有额外加分的练习 —— 这时你才需要在这些代码上思考如何实现函数式编程。

在 `ch11-code/stock-ticker-events.js` 中，我们创建了一些 observable（通过 RxJS）连接到事件发送器对象上。我们调用 `connectToServer()` 来获取这个事件的发射器，然后监听名称为 `"stock"` 的事件，通过这个事件来添加一个新的股票代码，同时监听名称为 `"stock-update"` 的事件，通过这个事件来更新股票价格和涨跌幅。最后，我们定义一些转换函数，来对这些 observable 传入的数据进行格式化。

在 `ch11-code/stock-ticker.js` 中，我们将我们的界面操作（DOM 部分的副作用）定义在 `stockTickerUI` 对象上的方法中。我们还定义了各种辅助函数，包括 `getElemAttr(..)`，`stripPrefix(..)` 等等。最后，我们通过 `subscribe(..)` 监听两个 observable，来获得格式化好的数据，渲染到 DOM 上。

## 股票信息

我们来看看 `ch11-code/stock-ticker-events.js` 中的代码。我们将从一些基本的辅助函数开始：

```js
function addStockName(stock) {
	return setProp( "name", stock, stock.id );
}
function formatSign(val) {
	if (Number(val) > 0) {
		return `+${val}`;
	}
	return val;
}
function formatCurrency(val) {
	return `$${val}`;
}
function transformObservable(mapperFn,obsv){
	return obsv.map( mapperFn );
}
```

这些纯函数应该很容易理解。回忆起在第 4 章 `setProp(..)` 在设置新属性之前复制了对象。这使用到了我们在第 6 章中学习到的原则：通过把变量当作不可变的变量来避免避免副作用，即使变量本身不是不可变变量。

`addStockName(..)` 用来在股票信息中添加一个 `name` 属性，作为 `id`。`name` 之后会被展示在工具中作为股票的名称。

关于 `transformObservable(..)` 做一个解释：表面上看起来在 `map(..)` 函数中返回一个新的 observable 是纯粹的。但是事实上，`obsv` 的内部状态被改变了，从而能够和 `map(..)` 返回的新的 observable 连接起来。这个副作用并不是个大问题，而且不会影响我们的代码可读性，但是重要的是是要发现副作用，而不是在遇到错误时感到惊讶！

当从「服务器」获取股票信息时，数据是这样的：

```js
{ id: "AAPL", price: 121.7, change: 0.01 }
```

在显示到 DOM 上之前，`price` 需要用 `formatCurrency(..)` 函数格式化（比如 `"$121.70"`），`change` 需要用 `formatChange(..)` 函数格式化（比如 `"+0.01"`）。但是我们不希望修改消息对象，所以我们需要一个辅助函数来格式化这些数字，并返回一个新的消息对象：

```js
function formatStockNumbers(stock) {
	var updateTuples = [
		[ "price", formatPrice( stock.price ) ],
		[ "change", formatChange( stock.change ) ]
	];

	return reduce( function formatter(stock,[propName,val]){
		return setProp( propName, stock, val );
	} )
	( stock )
	( updateTuples );
}
```

我们创建了 `updateTuples` 元组来保存 `price` 和 `change` 的信息，包括属性名称和格式化好的值。我们把 `stock` 对象作为 `initialValue`，对元组进行 `reduce(..)`（参考第 8 章）。我们把元组中的信息解构成 `propName` 和 `val`，然后返回了 `setProp(..)` 调用的结果，这个结果是一个被复制了的新的对象，其中的属性被修改过了。

下面我们再定义几个辅助函数：

```js
var formatDecimal = unboundMethod( "toFixed" )( 2 );
var formatPrice = pipe( formatDecimal, formatCurrency );
var formatChange = pipe( formatDecimal, formatSign );
var processNewStock = pipe( addStockName, formatStockNumbers );
```

`formatDecimal(..)` 函数接收一个数字作为参数（如 `2.1`）并且调用数字的 `toFixed( 2 )` 方法。我们使用了第 8 章介绍的 `unboundMethod(..)` 来创建一个独立的延迟绑定函数。

`formatPrice(..)`，`formatChange(..)` 和 `processNewStock(..)` 都用到了 `pipe(..)` 来从左到右地组合运算（见第 4 章）。

为了能在事件发送器的基础上创建 observable（见第 10 章），我们将封装一个独立的柯里化辅助函数（见第 3 章）来包装 RxJS 的 `Rx.Observable.fromEvent(..)`。

```js
var makeObservableFromEvent = curry( Rx.Observable.fromEvent, 2 )( server );
```

这个函数特定地监听了 `server`（事件发送器），在接受了时间名称字符串参数后，就能生成 observable 了。我们准备好了创建 observer 的所有代码片段后，用映射函数转换 observer 来格式化获取到的数据：

```js
var observableMapperFns = [ processNewStock, formatStockNumbers ];

var [ newStocks, stockUpdates ] = pipe(
	map( makeObservableFromEvent ),
	curry( zip )( observableMapperFns ),
	map( spreadArgs( transformObservable ) )
)
( [ "stock", "stock-update" ] );
```

我们创建了包含了事件名称（`["stock","stock-update"]`）的数组，然后 `map(..)`（见第 8 章）这个数组，生成了一个包含了两个 observable 的数组，然后把这个数组和 observable 映射函数 `zip(..)`（见第 8 章）起来，产生一个 `[ observable, mapperFn ]` 这样的元组数组。最后，我们把元组数组通过 `spreadArgs(..)`（见第 3 章）把每个元组展开成参数， `map(..)` 到了 `transformObservable(..)` 函数上。

得到的结果是一个包含了转换好的 observable 的数组，通过数组结构赋值的方式分别赋值到了 `newStocks` 和 `stockUpdates` 两个变量上。

到此为止，我们用轻量函数式编程的方式来让股票行情信息事件成为了 observable！在 `ch11-code/stock-ticker.js` 中我们会订阅这两个 observable。

回头想想我们用到的函数式编程原则。这样做有没有意义呢？你能否明白我们是如何运用前几章中介绍的各种概念的呢？你能不能想到别的方式来实现这些功能？

更重要的是，如果你用命令式编程的方法是如何实现上面的功能的呢？你认为两种方式相比孰优孰劣？试试看用你熟悉的命令式编程的方式去写这个功能。如果你和我一样，那一定会觉得命令式的方式依然非常自然。

在继续下去之前，你需要理解的我们刚才用到的函数式编程方式。想想看每个函数的输入和输出。你看懂为什么他们能组合在一起了吗？

在你理解了这些思想之前，多练习。

## 股票行情界面

如果你熟悉了上一章节中的函数式编程模式，你就可以开始学习 `ch11-code/stock-ticker.js` 文件中的内容了。这里会涉及相当多的重要内容，所以我们将好好地理解整个文件中的每个方法。

我们先从定义一些操作 DOM 的辅助函数开始：

```js
function isTextNode(node) {
	return node && node.nodeType == 3;
}
function getElemAttr(elem,prop) {
	return elem.getAttribute( prop );
}
function setElemAttr(elem,prop,val) {
	// !!SIDE EFFECTS!!
	return elem.setAttribute( prop, val );
}
function matchingStockId(id) {
	return function isStock(node){
		return getStockId( node ) == id;
	};
}
function isStockInfoChildElem(elem) {
	return /\bstock-/i.test( getClassName( elem ) );
}
function appendDOMChild(parentNode,childNode) {
	// !!SIDE EFFECTS!!
	parentNode.appendChild( childNode );
	return parentNode;
}
function setDOMContent(elem,html) {
	// !!SIDE EFFECTS!!
	elem.innerHTML = html;
	return elem;
}

var createElement = document.createElement.bind( document );

var getElemAttrByName = curry( reverseArgs( getElemAttr ), 2 );
var getStockId = getElemAttrByName( "data-stock-id" );
var getClassName = getElemAttrByName( "class" );
```

这些函数应该算是不言自明的。为了获得 `getElemAttrByName(..)`，我用了 `curry(reverseArgs( .. ))`（见第 3 章）而不是 `partialRight(..)`，只是为了在这种特殊情况下，稍微提高一点性能。

注意，我标出了操作 DOM 元素时的副作用。我们不能简单地通过克隆 DOM 对象并修改它来实现我们的功能，所以我们改变了原来的对象，产生了一些副作用。至少如果在 DOM 渲染中产生一个错误，我们可以轻松地搜索这些代码注释来缩小可能的错误代码。

`matchingStockId(..)` 用到了闭包（见第 2 章），创建了一个内部函数（`isStock(..)`），使在其他作用域下运行时依然能够保存 `id` 变量。

其他的辅助函数：

```js
function stripPrefix(prefixRegex) {
	return function mapperFn(val) {
		return val.replace( prefixRegex, "" );
	};
}
function listify(listOrItem) {
	if (!Array.isArray( listOrItem )) {
		return [ listOrItem ];
	}
	return listOrItem;
}
```

我们来定义一个辅助函数来帮我们获取某个 DOM 元素的子元素：

```js
var getDOMChildren = pipe(
	listify,
	flatMap(
		pipe(
			curry( prop )( "childNodes" ),
			Array.from
		)
	)
);
```

首先，用 `listify(..)` 来保证我们得到的是一个数组（即使里面只有一个元素）。回忆一下在第 8 章中提到的 `flatMap(..)`，把一个包含数组的数组扁平化，变成一个浅数组。

映射函数先把 DOM 元素映射成它的字元素数组，然后我们用 `Array.from(..)` 把这个数组变成一个真实的数组（而不是一个 NodeList）。这两个函数组合成一个映射函数（通过 `pipe(..)`），用到了融合（见第 8 章）。

现在，我们用 `getDOMChildren(..)` 辅助函数来定义股票行情工具中查找特定 DOM 元素的工具函数：

```js
function getStockElem(tickerElem,stockId) {
	return pipe(
		getDOMChildren,
		filterOut( isTextNode ),
		filterIn( matchingStockId( stockId ) )
	)
	( tickerElem );
}
function getStockInfoChildElems(stockElem) {
	return pipe(
		getDOMChildren,
		filterOut( isTextNode ),
		filterIn( isStockInfoChildElem )
	)
	( stockElem );
}
```

`getStockElem(..)` 接受 `tickerElem` DOM 节点作为参数，获取其子元素，然后过滤，保证我们得到的是符合股票代码的 DOM 元素。`getStockInfoChildElems(..)` 几乎是一样的，不同的是它从一个股票元素节点开始查找，还使用了不同的过滤函数。

两个工具函数都会过滤掉文字节点（因为它们没有其他的 DOM 节点那样的方法），保证返回一个 DOM 元素数组，哪怕数组中只有一个元素。

### 主函数

我们用 `stockTickerUI` 对象来保存三个修改界面的主要方法，如下：

```js
var stockTickerUI = {

	updateStockElems(stockInfoChildElemList,data) {
		// ..
	},

	updateStock(tickerElem,data) {
		// ..
	},

	addStock(tickerElem,data) {
		// ..
	}
};
```

我们先看看 `updateStock(..)`，这是三个函数里面最简单的：

```js
var stockTickerUI = {

	// ..

	updateStock(tickerElem,data) {
		var getStockElemFromId = curry( getStockElem )( tickerElem );
		var stockInfoChildElemList = pipe(
			getStockElemFromId,
			getStockInfoChildElems
		)
		( data.id );

		return stockTickerUI.updateStockElems(
			stockInfoChildElemList,
			data
		);
	},

	// ..

};
```

柯里化之前的辅助函数 `getStockElem(..)`，传给它 `tickerElem`，得到了 `getStockElemFromId(..)` 函数，这个函数接受 `data.id` 作为参数。把 `<li>` 元素（其实是数组形式的）传入 `getStockInfoChildElems(..)`，我们得到了三个 `<span>` 子元素，用来展示股票信息，我们把它们保存在 `stockInfoChildElemList` 变量中。然后把数组和股票信息 `data` 对象一起传给 `stockTickerUI.updateStockElems(..)`，来更新 `<span>` 中的数据。

现在我们来看看 `stockTickerUI.updateStockElems(..)`：

```js
var stockTickerUI = {

	updateStockElems(stockInfoChildElemList,data) {
		var getDataVal = curry( reverseArgs( prop ), 2 )( data );
		var extractInfoChildElemVal = pipe(
			getClassName,
			stripPrefix( /\bstock-/i ),
			getDataVal
		);
		var orderedDataVals =
			map( extractInfoChildElemVal )( stockInfoChildElemList );
		var elemsValsTuples =
			filterOut( function updateValueMissing([infoChildElem,val]){
				return val === undefined;
			} )
			( zip( stockInfoChildElemList, orderedDataVals ) );

		// !!SIDE EFFECTS!!
		compose( each, spreadArgs )
		( setDOMContent )
		( elemsValsTuples );
	},

	// ..

};
```

这部分有点难理解。我们一行行来看。

首先把 `prop` 函数的参数反转，柯里化后，把 `data` 消息对象绑定上去，得到了 `getDataVal(..)` 函数，这个函数接收一个属性名称作为参数，返回 `data` 中的对应的属性名称的值。

接下来，我们看看 `extractInfoChildElem`：

```js
var extractInfoChildElemVal = pipe(
	getClassName,
	stripPrefix( /\bstock-/i ),
	getDataVal
);
```

这个函数接受一个 DOM 元素作为参数，拿到 class 属性的值，然后把 `"stock-"` 前缀去掉，然后用这个属性值（`"name"`，`"price"` 或 `"change"`），通过 `getDataVal(..)` 函数，在 `data` 中找到对应的数据。你可能会问：「还有这种操作？」。

其实，这么做的目的是按照 `stockInfoChildElemList` 中的 `<span>` 元素的顺序从 `data` 中拿到数据。我们对 `orderedDataVals` 数组调用 `extractInfoChildElem` 映射函数，来拿到这些数据。

接来下，我们把 `<span>` 数组和数据数组压缩起来，得到一个元组：

```js
zip( stockInfoChildElemList, orderedDataVals )
```

这里有一点不太容易理解，我们定义的 observable 转换函数中，新的股票行情数据 `data` 会包含一个 `name` 属性，来对应 `<span class="stock-name">` 元素，但是在股票行情更新事件的数据中可能会找不到对应的 `name` 属性。

一般来说，如果股票更新消息事件的数据对象不包含某个股票数据的话，我们就不应该更新这只股票对应的 DOM 元素。所以我们要用 `filterOut(..)` 剔除掉没有值的元组（这里的值在元组的第二个元素）。

```js
var elemsValsTuples =
	filterOut( function updateValueMissing([infoChildElem,val]){
		return val === undefined;
	} )
	( zip( stockInfoChildElemList, orderedDataVals ) );
```

筛选后的结果是一个元组数组（如：`[ <span>, ".." ]`），这个数组可以用来更新 DOM 了，我们把这个结果保存到 `elemsValsTuples` 变量中。

**注意：** 既然 `updateValueMissing(..)` 是声明在函数内的，所以我们可以更方便地控制这个函数。与其使用 `spreadArgs(..)` 来把函数接收的一个数组形式的参数展开成两个参数，我们可以直接用函数的参数解构声明（`function updateValueMissing([infoChildElem,val]){ ..`），参见第 2 章。

最后，我们要更新 DOM 中的 `<span>` 元素：

```js
// !!SIDE EFFECTS!!
compose( each, spreadArgs )( setDOMContent )
( elemsValsTuples );
```

我们用 `each(..)` 遍历了 `elemsValsTuples` 数组（参考第 8 章中关于 `forEach(..)` 的讨论）。

不像其他地方用了 `pipe(..)`，这里组合函数的时候用了 `compose(..)`（见第 4 章），先把 `setDomContent(..)` 传到 `spreadArgs(..)` 中，再把执行的结果传到了迭代函数 `each(..)` 中。每个元组被展开后，作为参数传给了 `setDOMContent(..)` 函数，然后对应地更新 DOM 元素。

最后说明下 `addStock(..)`。我们先把整个函数写出来，然后再一句句地解释：

```js
var stockTickerUI = {

	// ..

	addStock(tickerElem,data) {
		var [stockElem, ...infoChildElems] = map(
			createElement
		)
		( [ "li", "span", "span", "span" ] );
		var attrValTuples = [
			[ ["class","stock"], ["data-stock-id",data.id] ],
			[ ["class","stock-name"] ],
			[ ["class","stock-price"] ],
			[ ["class","stock-change"] ]
		];
		var elemsAttrsTuples =
			zip( [stockElem, ...infoChildElems], attrValTuples );

		// !!SIDE EFFECTS!!
		each( function setElemAttrs([elem,attrValTupleList]){
			each(
				spreadArgs( partial( setElemAttr, elem ) )
			)
			( attrValTupleList );
		} )
		( elemsAttrsTuples );

		// !!SIDE EFFECTS!!
		stockTickerUI.updateStockElems( infoChildElems, data );
		reduce( appendDOMChild )( stockElem )( infoChildElems );
		tickerElem.appendChild( stockElem );
	}

};
```

这个操作界面的函数会根据新的股票信息生成一个空的 DOM 结构，然后调用 `stockTickerUI.updateStockElems(..)` 方法来更新其中的内容。

首先：

```js
var [stockElem, ...infoChildElems] = map(
	createElement
)
( [ "li", "span", "span", "span" ] );
```

我们先创建 `<li>` 父元素和三个 `<span>` 子元素，把它们分别赋值给了 `stockElem` 和 `infoChildElems` 数组。

为了设置 DOM 元素的对应属性，我们声明了一个元组数组组成的数组。按照顺序，每个元组数组对应上面四个 DOM 元素中的一个。每个元组数组中的元组由属性和值组成：

```js
var attrValTuples = [
	[ ["class","stock"], ["data-stock-id",data.id] ],
	[ ["class","stock-name"] ],
	[ ["class","stock-price"] ],
	[ ["class","stock-change"] ]
];
```

我们把四个 DOM 元素和 `attrValTuples` 数组 `zip(..)` 起来：

```js
var elemsAttrsTuples =
	zip( [stockElem, ...infoChildElems], attrValTuples );
```

最后的结果会是：

```
[
	[ <li>, [ ["class","stock"], ["data-stock-id",data.id] ] ],
	[ <span>, [ ["class","stock-name"] ] ],
	..
]
```

如果我们用命令式的方式来把属性和值设置到每个 DOM 元素上，我们会用嵌套的 `for` 循环。用函数式的方式的话也会是这样，不过这时嵌套的是 `each(..)` 循环：

```js
// !!SIDE EFFECTS!!
each( function setElemAttrs([elem,attrValTupleList]){
	each(
		spreadArgs( partial( setElemAttr, elem ) )
	)
	( attrValTupleList );
} )
( elemsAttrsTuples );
```

外层的 `each(..)` 循环了元组数组，其中每个数组的元素是一个 `elem` 和它对应的 `attrValTupleList`，这个元组数组被传入了 `setElemAttrs(..)`，在函数的参数中被解构成两个值。

在外层循环内，元组数组的子数组（包含了属性和值的数组）被传递到了内层的 `each(..)` 循环中。在内层的循环中，先绑定了 `setElemAttr(..)` 中的第一个参数 `elem`，然后把剩下的函数参数展开，最后把子数组作为参数传给了这个函数。

到此为止，我们有了 `<span>` 元素数组，每个元素上都有了该有的属性，但是还没有 `innerHTML` 的内容。这里，我们要用 `stockTickerUI.updateStockElems(..)` 函数，把 `data` 设置到 `<span>` 上去，和股票信息更新事件的处理一样。

然后，我们要把这些 `<span>` 元素添加到对应的父级 `<li>` 元素中去，我们用 `reduce(..)` 来做这件事（见第 8 章）。

```js
reduce( appendDOMChild )( stockElem )( infoChildElems );
```

最后，用操作 DOM 元素的副作用方法把新的股票元素添加到小工具的 DOM 节点中去：

```js
tickerElem.appendChild( stockElem );
```

呼！你跟上了吗？我建议你在继续下去之前，回到开头，重新读几遍这部分内容，再练习几遍。

### Subscribing To Observables

Our last major task is to subscribe to the observables defined in `ch11-code/stock-ticker-events.js`, attaching these subscriptions to the appropriate main UI methods (`addStock(..)` and `updateStock(..)`).

First, we notice that those methods each expect `tickerElem` as first parameter. Let's make a list (`stockTickerUIMethodsWithDOMContext`) that encapsulates the ticker widget's DOM element with each of these two methods, via partial application (aka, closure; see Chapter 2):

```js
var ticker = document.getElementById( "stock-ticker" );

var stockTickerUIMethodsWithDOMContext = map(
	curry( reverseArgs( partial ), 2 )( ticker )
)
( [ stockTickerUI.addStock, stockTickerUI.updateStock ] );
```

`reverseArgs( partial )` is the same performance-optimized `partialRight(..)` substitute from earlier. But this time, `partial(..)` is the intended mapper function. To accomplish that, we need to `curry(..)` it so we can pre-specify the second argument `ticker` ahead of time; when each UI method is then mapped, it partially applies that function with `ticker`. The two partially-applied functions in the resulting array are now suitable for observable subscription.

Though we're using closure to preserve the `ticker` state with these two functions, in Chapter 7 we saw that we could have "kept" this `ticker` value as a property on an object, perhaps via `this`-binding each function to `stockTickerUI`. Since `this` is an implicit input (see Chapter 2) and that's generally not as preferable, I choose the closure form over the object form.

To subscribe to the observables, let's make an unbound-method helper:

```js
var subscribeToObservable =
	pipe( uncurry, spreadArgs )( unboundMethod( "subscribe" ) );
```

`unboundMethod("subscribe")` is automatically curried, so we `uncurry(..)` it (see Chapter 3), then adapt it with `spreadArgs(..)` (again, see Chapter 3) so it'll spread out a single tuple array as its two arguments.

Now, we just need a list of the observables, so we can `zip(..)` that with the list of context-encapsulated UI methods. That list of tuples can then each be subscribed with the `subscribeToObservable(..)` helper we just defined in the previous snippet:

```js
var stockTickerObservables = [ newStocks, stockUpdates ];

// !!SIDE EFFECTS!!
each( subscribeToObservable )
( zip( stockTickerUIMethodsWithDOMContext, stockTickerObservables ) );
```

Since we're technically mutating the state of those observables to subscribe to them, and moreover since we're using `each(..)` -- pretty much always associated with side effects! -- we call that fact out with our code comment.

That's it! Spend the same time reviewing and comparing this code to its imperative alternatives as we did in with the stock ticker events discussion earlier. Really, take your time. I know it's been a long book, but your whole reading comes down to being able to digest and understand this kind of code.

How do you feel now about using FP in a balanced way in your JavaScript? Keep practicing just like we did here!

## Summary

The example code we discussed in this chapter should be viewed in its entirety, not just in the broken out snippets as presented in this chapter. Stop right now and go read through the full files, if you haven't already. Make sure you understand them in full context.

This example code is not meant to be prescriptive of exactly how you should write your code. It's meant to be more descriptive of how to think about and begin approaching such tasks with FP-light techniques. It's meant to draw as many correlations between the different concepts of this book as possible. It's meant to explore FP in the context of more "real" code than we typically afford for a single snippet.

I am quite sure that as I learn FP better on my own journey, I will continue to improve how I would write this example code. What you see now is just a snapshot on my curve. I hope it will just be such for you, as well.

As we draw the main text of this book to a close, I want to remind you of this readability curve that I shared back in Chapter 1:

<p align="center">
	<img src="fig17.png" width="600">
</p>

It's so important that you internalize the truth of that graph and set realistic expectations for yourself on this journey to learn and apply FP principles to your JavaScript. You've made it this far, and that's quite an accomplishment.

But don't stop when you dip towards that trough of despair and disenchantment. What's waiting on the other side is a way of thinking about and communicating with your code that's more readable, understandable, verifable, and ultimately, more reliable.

I can't think of any more noble goal for us as developers to strive towards. Thanks for sharing in my journey to learn FP principles in JavaScript. I hope your's is as rich and hopeful as mine!
