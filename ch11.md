# 轻量函数式编程
# 第 11 章：融会贯通

现在你已经掌握了所有需要掌握的关于轻量函数式编程的内容。下面不会再介绍新的概念。

在最后一章中，我们的目标是把概念融会贯通起来。我们将应用我们所学到的知识，把书中的概念结合起来。这段代码解释了在 JavaScript 中运用「轻量函数式编程」时，如何做到既实用又符合规范。

后面你将会大量的运用这些技巧。而理解本章的内容将对你在实际项目中运用函数式编程有极大的帮助。

## 准备

我们来写一个简单的股票行情工具吧。

**注意：** 作为参考，完整的代码在 `ch11-code/` 子目录下，可以在本书的 GitHub 仓库（[https://github.com/getify/Functional-Light-JS](https://github.com/getify/Functional-Light-JS)）下找到。同时，在书中讨论到的函数式编程辅助函数的基础上，我们筛选了所需的一部分放到了 `ch11-code/fp-helpers.js` 文件中。本章中，我们只会讨论到其中相关的部分。

首先，我们写工具的 HTML 部分，这样就可以有地方展示信息了。我们在 `ch11-code/index.html` 文件中先写一个空的 `<ul ..>` 元素，但是在运行时，DOM 会被填充成：

```html
<ul id="stock-ticker">
	<li class="stock" data-stock-id="AAPL">
		<span class="stock-name">AAPL</span>
		<span class="stock-price">$121.95</span>
		<span class="stock-change">+0.01</span>
	</li>
	<li class="stock" data-stock-id="MSFT">
		<span class="stock-name">MSFT</span>
		<span class="stock-price">$65.78</span>
		<span class="stock-change">+1.51</span>
	</li>
	<li class="stock" data-stock-id="GOOG">
		<span class="stock-name">GOOG</span>
		<span class="stock-price">$821.31</span>
		<span class="stock-change">-8.84</span>
	</li>
</ul>
```

在继续下去之前，我要提醒一下，操作 DOM 是 I/O，所以这是副作用。我们不能消除这些副作用，但是我们可以限制它们。我们尽量减少和 DOM 相关的操作。这些技巧在第 5 章中已经提到了。

概括一下我们的小工具的功能：代码将在每次添加新股票事件“收到”时添加 `<li ..>` 元素，并在股票价格更新事件发生时更新价格。

在第 11 章的示例代码 `ch11-code/mock-server.js` 中，我们设置了一些定时器，把随机生成的假股票数据推送到一个简单的事件发送器中，来模拟从服务器收到的股票数据。我们暴露了一个 `connectToServer()` 接口来实现模拟，但是实际上，它只是返回了一个假的事件发送器。

**注意：** 这个文件是用来模拟的，所以我没有花费太多的精力让它非常符合函数式编程。不建议大家花太多时间研究这个文件中的代码。如果你写了一个真正的服务器 —— 对于有雄心勃勃的读者来说，这是一个非常有趣的和有额外加分的练习 —— 这时你才需要在这些代码上思考如何实现函数式编程。

在 `ch11-code/stock-ticker-events.js` 中，我们创建了一些 observable（通过 RxJS）连接到事件发送器对象上。我们调用 `connectToServer()` 来获取这个事件的发射器，然后监听名称为 `"stock"` 的事件，通过这个事件来添加一个新的股票代码，同时监听名称为 `"stock-update"` 的事件，通过这个事件来更新股票价格和涨跌幅。最后，我们定义一些转换函数，来对这些 observable 传入的数据进行格式化。

在 `ch11-code/stock-ticker.js` 中，我们将我们的界面操作（DOM 部分的副作用）定义在 `stockTickerUI` 对象上的方法中。我们还定义了各种辅助函数，包括 `getElemAttr(..)`，`stripPrefix(..)` 等等。最后，我们通过 `subscribe(..)` 监听两个 observable，来获得格式化好的数据，渲染到 DOM 上。

## 股票信息

我们来看看 `ch11-code/stock-ticker-events.js` 中的代码。我们将从一些基本的辅助函数开始：

```js
function addStockName(stock) {
	return setProp( "name", stock, stock.id );
}
function formatSign(val) {
	if (Number(val) > 0) {
		return `+${val}`;
	}
	return val;
}
function formatCurrency(val) {
	return `$${val}`;
}
function transformObservable(mapperFn,obsv){
	return obsv.map( mapperFn );
}
```

这些纯函数应该很容易理解。回忆起在第 4 章 `setProp(..)` 在设置新属性之前复制了对象。这使用到了我们在第 6 章中学习到的原则：通过把变量当作不可变的变量来避免避免副作用，即使变量本身不是不可变变量。

`addStockName(..)` 用来在股票信息中添加一个 `name` 属性，作为 `id`。`name` 之后会被展示在工具中作为股票的名称。

关于 `transformObservable(..)` 做一个解释：表面上看起来在 `map(..)` 函数中返回一个新的 observable 是纯粹的。但是事实上，`obsv` 的内部状态被改变了，从而能够和 `map(..)` 返回的新的 observable 连接起来。这个副作用并不是个大问题，而且不会影响我们的代码可读性，但是重要的是是要发现副作用，而不是在遇到错误时感到惊讶！

当从「服务器」获取股票信息时，数据是这样的：

```js
{ id: "AAPL", price: 121.7, change: 0.01 }
```

在显示到 DOM 上之前，`price` 需要用 `formatCurrency(..)` 函数格式化（比如 `"$121.70"`），`change` 需要用 `formatChange(..)` 函数格式化（比如 `"+0.01"`）。但是我们不希望修改消息对象，所以我们需要一个辅助函数来格式化这些数字，并返回一个新的消息对象：

```js
function formatStockNumbers(stock) {
	var updateTuples = [
		[ "price", formatPrice( stock.price ) ],
		[ "change", formatChange( stock.change ) ]
	];

	return reduce( function formatter(stock,[propName,val]){
		return setProp( propName, stock, val );
	} )
	( stock )
	( updateTuples );
}
```

我们创建了 `updateTuples` 元组来保存 `price` 和 `change` 的信息，包括属性名称和格式化好的值。我们把 `stock` 对象作为 `initialValue`，对元组进行 `reduce(..)`（参考第 8 章）。我们把元组中的信息解构成 `propName` 和 `val`，然后返回了 `setProp(..)` 调用的结果，这个结果是一个被复制了的新的对象，其中的属性被修改过了。

下面我们再定义几个辅助函数：

```js
var formatDecimal = unboundMethod( "toFixed" )( 2 );
var formatPrice = pipe( formatDecimal, formatCurrency );
var formatChange = pipe( formatDecimal, formatSign );
var processNewStock = pipe( addStockName, formatStockNumbers );
```

`formatDecimal(..)` 函数接收一个数字作为参数（如 `2.1`）并且调用数字的 `toFixed( 2 )` 方法。我们使用了第 8 章介绍的 `unboundMethod(..)` 来创建一个独立的延迟绑定函数。

`formatPrice(..)`，`formatChange(..)` 和 `processNewStock(..)` 都用到了 `pipe(..)` 来从左到右地组合运算（见第 4 章）。

为了能在事件发送器的基础上创建 observable（见第 10 章），我们将封装一个独立的柯里化辅助函数（见第 3 章）来包装 RxJS 的 `Rx.Observable.fromEvent(..)`。

```js
var makeObservableFromEvent = curry( Rx.Observable.fromEvent, 2 )( server );
```

这个函数特定地监听了 `server`（事件发送器），在接受了时间名称字符串参数后，就能生成 observable 了。我们准备好了创建 observer 的所有代码片段后，用映射函数转换 observer 来格式化获取到的数据：

```js
var observableMapperFns = [ processNewStock, formatStockNumbers ];

var [ newStocks, stockUpdates ] = pipe(
	map( makeObservableFromEvent ),
	curry( zip )( observableMapperFns ),
	map( spreadArgs( transformObservable ) )
)
( [ "stock", "stock-update" ] );
```

我们创建了包含了事件名称（`["stock","stock-update"]`）的数组，然后 `map(..)`（见第 8 章）这个数组，生成了一个包含了两个 observable 的数组，然后把这个数组和 observable 映射函数 `zip(..)`（见第 8 章）起来，产生一个 `[ observable, mapperFn ]` 这样的元组数组。最后，我们把元组数组通过 `spreadArgs(..)`（见第 3 章）把每个元组展开成参数， `map(..)` 到了 `transformObservable(..)` 函数上。

得到的结果是一个包含了转换好的 observable 的数组，通过数组结构赋值的方式分别赋值到了 `newStocks` 和 `stockUpdates` 两个变量上。

到此为止，我们用轻量函数式编程的方式来让股票行情信息事件成为了 observable！在 `ch11-code/stock-ticker.js` 中我们会订阅这两个 observable。

回头想想我们用到的函数式编程原则。这样做有没有意义呢？你能否明白我们是如何运用前几章中介绍的各种概念的呢？你能不能想到别的方式来实现这些功能？

更重要的是，如果你用命令式编程的方法是如何实现上面的功能的呢？你认为两种方式相比孰优孰劣？试试看用你熟悉的命令式编程的方式去写这个功能。如果你和我一样，那一定会觉得命令式的方式依然非常自然。

在继续下去之前，你需要理解的我们刚才用到的函数式编程方式。想想看每个函数的输入和输出。你看懂为什么他们能组合在一起了吗？

在你理解了这些思想之前，多练习。

## 股票行情界面

如果你熟悉了上一章节中的函数式编程模式，你就可以开始学习 `ch11-code/stock-ticker.js` 文件中的内容了。这里会涉及相当多的重要内容，所以我们将好好地理解整个文件中的每个方法。

我们先从定义一些操作 DOM 的辅助函数开始：

```js
function isTextNode(node) {
	return node && node.nodeType == 3;
}
function getElemAttr(elem,prop) {
	return elem.getAttribute( prop );
}
function setElemAttr(elem,prop,val) {
	// !!SIDE EFFECTS!!
	return elem.setAttribute( prop, val );
}
function matchingStockId(id) {
	return function isStock(node){
		return getStockId( node ) == id;
	};
}
function isStockInfoChildElem(elem) {
	return /\bstock-/i.test( getClassName( elem ) );
}
function appendDOMChild(parentNode,childNode) {
	// !!SIDE EFFECTS!!
	parentNode.appendChild( childNode );
	return parentNode;
}
function setDOMContent(elem,html) {
	// !!SIDE EFFECTS!!
	elem.innerHTML = html;
	return elem;
}

var createElement = document.createElement.bind( document );

var getElemAttrByName = curry( reverseArgs( getElemAttr ), 2 );
var getStockId = getElemAttrByName( "data-stock-id" );
var getClassName = getElemAttrByName( "class" );
```

这些函数应该算是不言自明的。为了获得 `getElemAttrByName(..)`，我用了 `curry(reverseArgs( .. ))`（见第 3 章）而不是 `partialRight(..)`，只是为了在这种特殊情况下，稍微提高一点性能。

注意，我标出了操作 DOM 元素时的副作用。我们不能简单地通过克隆 DOM 对象并修改它来实现我们的功能，所以我们改变了原来的对象，产生了一些副作用。至少如果在 DOM 渲染中产生一个错误，我们可以轻松地搜索这些代码注释来缩小可能的错误代码。

`matchingStockId(..)` 用到了闭包（见第 2 章），创建了一个内部函数（`isStock(..)`），使在其他作用域下运行时依然能够保存 `id` 变量。

其他的辅助函数：

```js
function stripPrefix(prefixRegex) {
	return function mapperFn(val) {
		return val.replace( prefixRegex, "" );
	};
}
function listify(listOrItem) {
	if (!Array.isArray( listOrItem )) {
		return [ listOrItem ];
	}
	return listOrItem;
}
```

我们来定义一个辅助函数来帮我们获取某个 DOM 元素的子元素：

```js
var getDOMChildren = pipe(
	listify,
	flatMap(
		pipe(
			curry( prop )( "childNodes" ),
			Array.from
		)
	)
);
```

首先，用 `listify(..)` 来保证我们得到的是一个数组（即使里面只有一个元素）。回忆一下在第 8 章中提到的 `flatMap(..)`，把一个包含数组的数组扁平化，变成一个浅数组。

映射函数先把 DOM 元素映射成它的字元素数组，然后我们用 `Array.from(..)` 把这个数组变成一个真实的数组（而不是一个 NodeList）。这两个函数组合成一个映射函数（通过 `pipe(..)`），用到了融合（见第 8 章）。

现在，我们用 `getDOMChildren(..)` 辅助函数来定义股票行情工具中查找特定 DOM 元素的工具函数：

```js
function getStockElem(tickerElem,stockId) {
	return pipe(
		getDOMChildren,
		filterOut( isTextNode ),
		filterIn( matchingStockId( stockId ) )
	)
	( tickerElem );
}
function getStockInfoChildElems(stockElem) {
	return pipe(
		getDOMChildren,
		filterOut( isTextNode ),
		filterIn( isStockInfoChildElem )
	)
	( stockElem );
}
```

`getStockElem(..)` 接受 `tickerElem` DOM 节点作为参数，获取其子元素，然后过滤，保证我们得到的是符合股票代码的 DOM 元素。`getStockInfoChildElems(..)` 几乎是一样的，不同的是它从一个股票元素节点开始查找，还使用了不同的过滤函数。

两个工具函数都会过滤掉文字节点（因为它们没有其他的 DOM 节点那样的方法），保证返回一个 DOM 元素数组，哪怕数组中只有一个元素。

### Main API

We'll use a `stockTickerUI` object to organize our three main UI manipulation methods, like this:

```js
var stockTickerUI = {

	updateStockElems(stockInfoChildElemList,data) {
		// ..
	},

	updateStock(tickerElem,data) {
		// ..
	},

	addStock(tickerElem,data) {
		// ..
	}
};
```

Let's first examine `updateStock(..)`, as its the simplest of the three:

```js
var stockTickerUI = {

	// ..

	updateStock(tickerElem,data) {
		var getStockElemFromId = curry( getStockElem )( tickerElem );
		var stockInfoChildElemList = pipe(
			getStockElemFromId,
			getStockInfoChildElems
		)
		( data.id );

		return stockTickerUI.updateStockElems(
			stockInfoChildElemList,
			data
		);
	},

	// ..

};
```

Currying the earlier helper `getStockElem(..)` with `tickerElem` gives us `getStockElemFromId(..)`, which will receive `data.id`. That `<li>` element (actually, a list of that element) is passed to `getStockInfoChildElems(..)`, giving us three child `<span>` elements for the stock display info, which we call `stockInfoChildElemList`. We pass this list and the stock `data` message object along to `stockTickerUI.updateStockElems(..)` for actually updating those `<span>`s with the updated data.

Now let's look at `stockTickerUI.updateStockElems(..)`:

```js
var stockTickerUI = {

	updateStockElems(stockInfoChildElemList,data) {
		var getDataVal = curry( reverseArgs( prop ), 2 )( data );
		var extractInfoChildElemVal = pipe(
			getClassName,
			stripPrefix( /\bstock-/i ),
			getDataVal
		);
		var orderedDataVals =
			map( extractInfoChildElemVal )( stockInfoChildElemList );
		var elemsValsTuples =
			filterOut( function updateValueMissing([infoChildElem,val]){
				return val === undefined;
			} )
			( zip( stockInfoChildElemList, orderedDataVals ) );

		// !!SIDE EFFECTS!!
		compose( each, spreadArgs )
		( setDOMContent )
		( elemsValsTuples );
	},

	// ..

};
```

That's a bit to take in, I know. But we'll break it down statement by statement.

`getDataVal(..)` is bound to the `data` message object, having been curried after argument-reversing, so it's waiting for a property name to extract from `data`.

Next, let's look at `extractInfoChildElem`:

```js
var extractInfoChildElemVal = pipe(
	getClassName,
	stripPrefix( /\bstock-/i ),
	getDataVal
);
```

This function takes a DOM element, gets it DOM class, strips the `"stock-"` prefix from it, then uses that value (`"name"`, `"price"`, or `"change"`) to extract a value of that same name from `data` via `getDataVal(..)`. On the surface, that may seem like a slightly strange action.

The purpose, though, is to extract the values from `data` in the same order as the `<span>` elements (in `stockInfoChildElemList`). We accomplish this by using `extractInfoChildElem(..)` as the mapping function over that list, calling the resulting list `orderedDataVals`.

Next, we're going to zip our list of `<span>`s with this list of values, producing tuples:

```js
zip( stockInfoChildElemList, orderedDataVals )
```

An interesting wrinkle that wasn't at all obvious up to this point is that because of how we defined the observables transforms, new-stock message objects will have a `name` property in `data` to match up with the `<span class="stock-name">` element, but `name` will be absent on stock-update message objects.

As a general notion, if the data message object doesn't have a property, we shouldn't update that corresponding DOM element. So, we need to `filterOut(..)` any tuples where the value (in this case, in the second position) is `undefined`:

```js
var elemsValsTuples =
	filterOut( function updateValueMissing([infoChildElem,val]){
		return val === undefined;
	} )
	( zip( stockInfoChildElemList, orderedDataVals ) );
```

The result after this filtering is a list of tuples (like `[ <span>, ".." ]`) ready for DOM content updating, which we assign to `elemsValsTuples`.

**Note:** Since the `updateValueMissing(..)` predicate is specified inline here, we're in control of its signature. Instead of using `spreadArgs(..)` to adapt it to spread out a single array argument as two individual named parameters, we use parameter array-destructuring in the function declaration (`function updateValueMissing([infoChildElem,val]){ ..`); see Chapter 2 for more information.

Finally, we need to update the DOM content of our `<span>` elements:

```js
// !!SIDE EFFECTS!!
compose( each, spreadArgs )( setDOMContent )
( elemsValsTuples );
```

We iterate this `elemsValsTuples` list with `each(..)` (see `forEach(..)` discussion in Chapter 8).

Instead of using `pipe(..)` as elsewhere, this composition uses `compose(..)` (see Chapter 4) to pass `setDomContent(..)` into `spreadArgs(..)`, and then that is passed as the iterator-function to `each(..)`. Each tuple is spread out as the arguments to `setDOMContent(..)`, which then updates the DOM element accordingly.

That's two of the main UI methods down, one to go: `addStock(..)`. Let's define it in its entirety, then we'll examine it step by step as before:

```js
var stockTickerUI = {

	// ..

	addStock(tickerElem,data) {
		var [stockElem, ...infoChildElems] = map(
			createElement
		)
		( [ "li", "span", "span", "span" ] );
		var attrValTuples = [
			[ ["class","stock"], ["data-stock-id",data.id] ],
			[ ["class","stock-name"] ],
			[ ["class","stock-price"] ],
			[ ["class","stock-change"] ]
		];
		var elemsAttrsTuples =
			zip( [stockElem, ...infoChildElems], attrValTuples );

		// !!SIDE EFFECTS!!
		each( function setElemAttrs([elem,attrValTupleList]){
			each(
				spreadArgs( partial( setElemAttr, elem ) )
			)
			( attrValTupleList );
		} )
		( elemsAttrsTuples );

		// !!SIDE EFFECTS!!
		stockTickerUI.updateStockElems( infoChildElems, data );
		reduce( appendDOMChild )( stockElem )( infoChildElems );
		tickerElem.appendChild( stockElem );
	}

};
```

This UI method needs to create the bare DOM structure for a new stock element, and then use `stockTickerUI.updateStockElems(..)` to update its content as already described.

First:

```js
var [stockElem, ...infoChildElems] = map(
	createElement
)
( [ "li", "span", "span", "span" ] );
```

We create the parent `<li>` and the three children `<span>` elements, assigning them respectively to `stockElem` and the `infoChildElems` list.

To initialize these elements with the appropriate DOM attributes, we create a list of lists-of-tuples. Each item in the main list represents the four DOM elements, in order. Each tuple inside each sub-list represents an attribute-value pair to be set on the corresponding DOM element:

```js
var attrValTuples = [
	[ ["class","stock"], ["data-stock-id",data.id] ],
	[ ["class","stock-name"] ],
	[ ["class","stock-price"] ],
	[ ["class","stock-change"] ]
];
```

We now want to `zip(..)` a list of the four DOM elements with this `attrValTuples` list:

```js
var elemsAttrsTuples =
	zip( [stockElem, ...infoChildElems], attrValTuples );
```

The structure of this list would look like:

```
[
	[ <li>, [ ["class","stock"], ["data-stock-id",data.id] ] ],
	[ <span>, [ ["class","stock-name"] ] ],
	..
]
```

If we wanted to imperatively process this kind of data structure to assign the attribute-value tuples into each DOM element, we'd probably use nested `for`-loops. Our FP approach will be similar, but with nested `each(..)` iterations:

```js
// !!SIDE EFFECTS!!
each( function setElemAttrs([elem,attrValTupleList]){
	each(
		spreadArgs( partial( setElemAttr, elem ) )
	)
	( attrValTupleList );
} )
( elemsAttrsTuples );
```

The outer `each(..)` iterates the list of tuples, with each `elem` and its associated `attrValTupleList` spread out as named parameters to `setElemAttrs(..)` via parameter array-destructuring as explained earlier.

Inside this outer iteration "loop", the sub-list of attribute-value tuples is iterated with an inner `each(..)`. The inner iterator-function is an arguments-spread (of each attribute-value tuple) for the partial-application of `setElemAttr(..)` with `elem` as its first argument.

At this point, we have a list of `<span>` elements, each filled out with attributes, but no `innerHTML` content. We set the `data` into the child `<span>` elements with `stockTickerUI.updateStockElems(..)`, the same as for a stock-update event.

Now, we need to append these `<span>`s to the parent `<li>`, and we do that with a `reduce(..)` (see Chapter 8):

```js
reduce( appendDOMChild )( stockElem )( infoChildElems );
```

Finally, a plain ol' DOM mutation side effect to append the new stock element to the widget's DOM:

```js
tickerElem.appendChild( stockElem );
```

Phew! Did you follow all that? I recommend you go back and re-read that discussion a few times and practice with the code, before moving on.

### Subscribing To Observables

Our last major task is to subscribe to the observables defined in `ch11-code/stock-ticker-events.js`, attaching these subscriptions to the appropriate main UI methods (`addStock(..)` and `updateStock(..)`).

First, we notice that those methods each expect `tickerElem` as first parameter. Let's make a list (`stockTickerUIMethodsWithDOMContext`) that encapsulates the ticker widget's DOM element with each of these two methods, via partial application (aka, closure; see Chapter 2):

```js
var ticker = document.getElementById( "stock-ticker" );

var stockTickerUIMethodsWithDOMContext = map(
	curry( reverseArgs( partial ), 2 )( ticker )
)
( [ stockTickerUI.addStock, stockTickerUI.updateStock ] );
```

`reverseArgs( partial )` is the same performance-optimized `partialRight(..)` substitute from earlier. But this time, `partial(..)` is the intended mapper function. To accomplish that, we need to `curry(..)` it so we can pre-specify the second argument `ticker` ahead of time; when each UI method is then mapped, it partially applies that function with `ticker`. The two partially-applied functions in the resulting array are now suitable for observable subscription.

Though we're using closure to preserve the `ticker` state with these two functions, in Chapter 7 we saw that we could have "kept" this `ticker` value as a property on an object, perhaps via `this`-binding each function to `stockTickerUI`. Since `this` is an implicit input (see Chapter 2) and that's generally not as preferable, I choose the closure form over the object form.

To subscribe to the observables, let's make an unbound-method helper:

```js
var subscribeToObservable =
	pipe( uncurry, spreadArgs )( unboundMethod( "subscribe" ) );
```

`unboundMethod("subscribe")` is automatically curried, so we `uncurry(..)` it (see Chapter 3), then adapt it with `spreadArgs(..)` (again, see Chapter 3) so it'll spread out a single tuple array as its two arguments.

Now, we just need a list of the observables, so we can `zip(..)` that with the list of context-encapsulated UI methods. That list of tuples can then each be subscribed with the `subscribeToObservable(..)` helper we just defined in the previous snippet:

```js
var stockTickerObservables = [ newStocks, stockUpdates ];

// !!SIDE EFFECTS!!
each( subscribeToObservable )
( zip( stockTickerUIMethodsWithDOMContext, stockTickerObservables ) );
```

Since we're technically mutating the state of those observables to subscribe to them, and moreover since we're using `each(..)` -- pretty much always associated with side effects! -- we call that fact out with our code comment.

That's it! Spend the same time reviewing and comparing this code to its imperative alternatives as we did in with the stock ticker events discussion earlier. Really, take your time. I know it's been a long book, but your whole reading comes down to being able to digest and understand this kind of code.

How do you feel now about using FP in a balanced way in your JavaScript? Keep practicing just like we did here!

## Summary

The example code we discussed in this chapter should be viewed in its entirety, not just in the broken out snippets as presented in this chapter. Stop right now and go read through the full files, if you haven't already. Make sure you understand them in full context.

This example code is not meant to be prescriptive of exactly how you should write your code. It's meant to be more descriptive of how to think about and begin approaching such tasks with FP-light techniques. It's meant to draw as many correlations between the different concepts of this book as possible. It's meant to explore FP in the context of more "real" code than we typically afford for a single snippet.

I am quite sure that as I learn FP better on my own journey, I will continue to improve how I would write this example code. What you see now is just a snapshot on my curve. I hope it will just be such for you, as well.

As we draw the main text of this book to a close, I want to remind you of this readability curve that I shared back in Chapter 1:

<p align="center">
	<img src="fig17.png" width="600">
</p>

It's so important that you internalize the truth of that graph and set realistic expectations for yourself on this journey to learn and apply FP principles to your JavaScript. You've made it this far, and that's quite an accomplishment.

But don't stop when you dip towards that trough of despair and disenchantment. What's waiting on the other side is a way of thinking about and communicating with your code that's more readable, understandable, verifable, and ultimately, more reliable.

I can't think of any more noble goal for us as developers to strive towards. Thanks for sharing in my journey to learn FP principles in JavaScript. I hope your's is as rich and hopeful as mine!
