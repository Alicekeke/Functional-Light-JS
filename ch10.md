# Functional-Light JavaScript
# Chapter 10: Functional Async
# 第十章：异步的函数式

At this point of the book, you now have all the raw concepts in place for the foundation of FP that I call "Functional-Light Programming". In this chapter, we're going to apply these concepts to a different context, but we won't really present particularly new ideas.

阅读到这里，你已经学习了我所说的所有轻量级函数式编程的基础概念，在本章节中，我们将把这些概念应有到不同的情景当中，但绝对不会有新的知识点。


So far, almost everything we've done is synchronous, meaning that we call functions with immediate inputs and immediately get back output values. A lot of work can be done this way, but it's not nearly sufficient for the entirety of a modern JS application. To be truly ready for FP in the real world of JS, we need to understand async FP.

到目前为止，我们所说的一切都是同步的，意味着我们调用函数【且传入参数】后马上就会得到返回值。大部分的情况下是没问题的，但这几乎满足不了现在的所有 JS 应用。<del>为了能在现在的 JS 环境里使用上函数式编程</del>，我们就需要去了解异步的函数式编程。

Our goal in this chapter is to expand our thinking about managing values with FP, to spread out such operations over time.

本章的目的是拓展我们对用函数式编程管理值的思维，<del>以便之后我们在更多的业务上应用。（接下来通过展开一些操作来理解）</del>

## Time As State
## 时间状态

The most complicated state in your entire application is time. That is, it's far easier to manage state when the transition from one state to another is immediate and affirmatively in your control. When the state of your application changes implicitly in response to events spread out over time, management becomes exponentially more difficult.

在你所有的应用里，最复杂的状态就是时间。我们很容易去管理那些状态改变时是立即和确定的。但是，如果状态随着时间因为响应事件而隐晦的变化，管理这些状态的难度将会成几何级增长。

Every part of how we've presented FP in this text has been about making code easier to read by making it more trustable and more predictable. When you introduce asynchrony to your program, those efforts take a big hit.

我们在本文中介绍的函数式编程可以让代码变得更可读，从而增强了可靠性和可预见性。但是当你添加异步操作到你的项目里的时候，这些影响将会大打折扣。

But let's be more explicit: it's not the mere fact that some operations don't finish synchronously that is concerning; firing off asynchronous behavior is easy. It's the coordination of the responses to these actions, each of which has the potential to change the state of your application, that requires so much extra effort.

<del>但是让我们更明确一点：并不是说一些操作不能用同步来完成，或者触发异步行为很容易。协调那些可能会改变应用程序的状态的响应，这需要大量额外的工作。</del>

So, is it better for you the author to take that effort, or should you just leave it to the reader of your code to figure out what the state of the program will be if A finishes before B, or vice versa? That's a rhetorical question but one with a pretty concrete answer from my perspective: to have any hope of making such complex code more readable, the author has to take a lot more concern than they normally would.

所以，作为作者的你最好付出一些努力，或者只是留给阅读你代码的人一个难题，去弄清楚如果A在B之前完成，项目中状态是什么，还有相反的情况是什么？这是一个浮夸的问题，但以我的观点来看，这有一个确切的答案：如果可以把复杂的代码变得更容易理解，作者就必须花费更多心思。

### Reducing Time
### 减少时间状态

One of the most important outcomes of async programming patterns is simplifying state change management by abstracting out time from our sphere of concern.

<del>异步编程最为重要的其中一点是通过抽象时间来简化状态变化的管理。</del>

To illustrate, let's first look at a scenario where a race condition (aka, time complexity) exists, and must be manually managed:

为说明这一点，让我们先来看下一种有竞争状态（又称，复杂时间）的糟糕情况，且必须手动去管理里面的状态：

```js
var customerId = 42;
var customer;

lookupCustomer( customerId, function onCustomer(customerRecord){
	var orders = customer ? customer.orders : null;
	customer = customerRecord;
	if (orders) {
		customer.orders = orders;
	}
} );

lookupOrders( customerId, function onOrders(customerOrders){
	if (!customer) {
		customer = {};
	}
	customer.orders = customerOrders;
} );
```

The `onCustomer(..)` and `onOrders(..)` callbacks are in a binary race condition. Assuming they both run, it's possible that either might run first, and it's impossible to predict which will happen.

回调函数 `onCustomer(..)` 和 `onOrders(..)`  之间是互为竞争关系。假设他们都在运行，两者都有可能先运行，那将无法预测到会发生什么。

If we could embed the call to `lookupOrders(..)` inside of `onCustomer(..)`, we'd be sure that `onOrders(..)` was running after `onCustomer(..)`. But we can't do that, because we need the two lookups to occur concurrently.

如果我们可以把 `lookupOrders(..)` 写到 `onCustomer(..)` 里面，那我们就可以确认 `onOrders(..)` 会在 `onCustomer(..)` 之后运行，但我们不能这么做，因为我们需要让 2 个查询同时执行。

So to normalize this time-based state complexity, we use a pairing of `if`-statement checks in the respective callbacks, along with an outer lexically-closed over variable `customer`. When each callback runs, it checks the state of `customer`, and thus determines its own relative ordering; if `customer` is unset for a callback, it's the first to run, otherwise it's the second.

所以，为了让这个基于时间的复杂状态正常化，我们用相应的 `if`-声明在各自的回调函数里来检查外部作用域的变量 `customer`。当各自的回调函数被执行，将会去检测 `customer` 的状态，从而确定各自的执行顺序，如果 `customer` 在回调函数里还没被定义，那他就是先运行的，否则则是第二个运行的。

This code works, but it's far from ideal in terms of readability. The time complexity makes this code harder to read.

这个代码是可行的，但是他违背了可读性的原则。复杂的时间让这个代码变得难以阅读。

Let's instead use a JS promise to factor time out of the picture:

让我们改用 JS promise 来把时间因素抽离出来：

```js
var customerId = 42;

var customerPromise = lookupCustomer( customerId );
var ordersPromise = lookupOrders( customerId );

customerPromise.then( function onCustomer(customer){
	ordersPromise.then( function onOrders(orders){
		customer.orders = orders;
	} );
} );
```

The `onOrders(..)` callback is now inside of the `onCustomer(..)` callback, so their relative ordering is guaranteed. The concurrency of the lookups is accomplished by making the `lookupCustomer(..)` and `lookupOrders(..)` calls separately before specifying the `then(..)` response handling.

现在 `onOrders(..)` 回调函数存在 `onCustomer(..)` 回调函数里，所以他们各自的执行顺序是可以保证的。在各自的 `then(..)` 运行之前 `lookupCustomer(..)` 和 `lookupOrders(..)` 被分别的调用，两个查询就已经并行的执行完了。

It may not be obvious, but there would otherwise inherently be a race condition in this snippet, were it not for how promises are defined to behave. If the lookup of the `orders` finishes before the `ordersPromise.then(..)` is called to provide an `onOrders(..)` callback, *something* needs to be smart enough to keep that `orders` list around until `onOrders(..)` can be called. In fact, the same concern could apply to `record` being present before `onCustomer(..)` is specified to receive it.

<del>这可能不太明显，但是这个代码里还有其他内在的竞争状态，promise 的定义没有被体现出来。如果 `orders` 的查询在把 `onOrders(..)` 回调函数传给 `ordersPromise.then(..)` 调用前完成，那么就需要*某些东西* 能足够聪明来保存 `orders` 直到 `onOrders(..)` 能被调用。事实上，同样的问题也出现在 `record` （或者说`customer`）是否有保存到被 `onCustomer(..)` 接受到</del>

That *something* is the same kind of time complexity logic we discussed with the previous snippet. But we don't have to worry about any of that complexity, either in the writing of this code or -- more importantly -- in the reading of it, because the promises take care of that time normalization for us.

这里的 *某些东西* 同样是我们之前讨论过的时间状态复杂的理由。但我们不必去担心这些复杂性，无论是编码或者是读（更为重要）这些代码的时候，因为对我们来说，promise 所处理的就是时间上的问题。

A promise represents a single (future) value in a time-independent manner. Moreover, extracting the value from a promise is the asynchronous form of the synchronous assignment (via `=`) of an immediate value. In other words, a promise spreads an `=` assignment operation out over time, but in a trustable (time-independent) fashion.

<del>promise 以时间无关的方式来作为一个<del>单一的值</del>。此外，获取 promise 的返回值是异步的，但却是通过同步的方法来赋值即时值。或者说， promise 给 `=` 操作符扩展随时间动态赋值的功能，通过可靠的（时间无关）的方法。</del>

We'll now explore how we similarly can spread various synchronous FP operations from earlier in this book asynchronously over time.

<del>接下来我们将探索如何以相同的方式用各种同步的函数式编程操作来执行之前书里异步。</del>

## Eager vs Lazy
## 积极的 vs 慵懒的

Eager and lazy in the realm of computer science aren't compliments or insults, but rather ways to describe whether an operation will finish right away or progress over time.

Eager 和 Lazy 在计算机科学的领域并不是表扬或者批评的意思，而是描述一个操作是否立即执行或者是延时执行。

The FP operations that we've seen in this text can be characterized as eager because they operate synchronously (right now) on a discrete immediate value or list/structure of values.

我们在本例子中看到的 FP 操作可以被称为 eager，因为他运行时会同步的获取到即时的值或者是列表/结构（？）的值。

Recall:
回忆下：

```js
var a = [1,2,3]

var b = a.map( v => v * 2 );

b;			// [2,4,6]
```

This mapping from `a` to `b` is eager because it operates on all the values in the `a` array at that moment, and produces a new `b` array. If you later modify `a`, for example adding a new value to the end of it, nothing will change about the contents of `b`. That's eager FP.

这里 `a` 到 `b` 的映射就是 eager，因为它在执行的那一刻映射了数组 `a` 里的所有的值，然后生成了一个新的数组 `b` 。即使之后你去修改 `a` ，比如说添加一个新的值到数组的最后一位，也不会影响到 `b` 的内容。这就是 eager 函数式编程。

But what would it look like to have a lazy FP operation? Consider something like this:

但是如果是一个 lazy 函数式编程操作呢？考虑下下面的情况：

```js
var a = [];

var b = mapLazy( a, v => v * 2 );

a.push( 1 );

a[0];		// 1
b[0];		// 2

a.push( 2 );

a[1];		// 2
b[1];		// 4
```

The `mapLazy(..)` we've imagined here essentially "listens" to the `a` array, and every time a new value is added to the end of it (with `push(..)`), it runs the `v => v * 2` mapping function and pushes the transformed value to the `b` array.

我们可以想象下 `mapLazy(..)` 本质上“监听”了数组 `a` ，只要一个新的值添加到数组的后面（使用 `push(..)` ），它都会运行映射函数 `v => v * 2` 并把改变后的值添加到数组 `b` 里。

**Note:** The implementation of `mapLazy(..)` has not been shown because this is a fictional illustration, not a real operation. To accomplish this kind of lazy operation pairing between `a` and `b`, they will need to be smarter than simple arrays.

**注意：** `mapLazy(..)` 的实现没有被写出来，是因为它是虚构的方法，是不存在的。如果要实现 `a` 和 `b` 之间的 lazy 操作，那么简单的数组就需要变得更加聪明。

Consider the benefits of being able to pair an `a` and `b` together, where any time you put a value into `a`, it's transformed and projected to `b`. That's the same kind of declarative FP power out of a `map(..)` operation, but now it can be stretched over time; you don't have to know all the values of `a` to set up the mapping.

考虑下把 `a` 和 `b` 关联到一起的好处，无论何时何地，你添加一个值进 `a` 里，它都将改变且映射到 `b` 里。它比同为声明式函数式编程的 `map(..)` 更强大，但现在它可以随时的变化，进行映射时你不用知道 `a` 里面所有的值。

## Reactive FP
## 响应式函数式编程

To understand how we could create and use a lazy mapping between two sets of values, we need to abstract our idea of list (array) a bit.

为了理解如何在2个值之间创建和使用 lazy 映射，我们需要去抽象我们对列表（数组）的想法。

Let's imagine a smarter kind of array, not one which simply holds values but one which lazily receives and responds (aka "reacts") to values. Consider:

让我们来想象一个聪明的数组，不只是简单的拥有值，还是一个懒惰地接受和响应（也就是“反应”）值的数组。考虑下：

```js
var a = new LazyArray();

var b = a.map( function double(v){
	return v * 2;
} );

setInterval( function everySecond(){
	a.push( Math.random() );
}, 1000 );
```

So far, this snippet doesn't look any different than a normal array. The only unusual thing is that we're used to the `map(..)` running eagerly and immediately producing a `b` array with all the currently mapped values from `a`. But the timer pushing random values into `a` is strange, since all those values are coming *after* the `map(..)` call.

至此，这段代码和普通的数组没有什么区别。唯一不常见的是我们积极的和立即的执行 `map(..)` 来映射数组 `a` 里现有的值从而生成数组 `b` ，奇怪的是定时器在 `map(..)` 调用*之后*往 `a` 里面添加随机的值。

But this fictional `LazyArray` is different; it assumes that values may come one at a time, over time. Just `push(..)` values in whenever you want. `b` will be a lazy mapping of whatever values eventually end up in `a`.

但是这个虚构的 `LazyArray` 有点不同，它假设了值可以随时的一个一个添加进去。就像 `push(..)` 值当你想要的时候。可以说 `b` 就是一个懒映射 `a` 最终值的数组。

Also, we don't really need to keep values in `a` or `b` once they've been handled; this special kind of array only holds a value only as long as its needed. So these arrays don't strictly grow in memory usage over time, an important characteristic of lazy data structures and operations. In fact, it's less like an array and more like a buffer.

此外，当 `a` 或者 `b` 改变时，我们不需要确切的保存里面的值，这个特殊的数组将会保存它所需的值。所以这些数组不会随着时间而占用更多的内存，这是 懒数据结构和懒操作的重要特点。事实上，它看起来不像数组，更像是buffer（缓冲流）。

A normal array is eager in that it holds all of its values right now. A "lazy array" is an array where the values will come in over time.

普通的数组是积极的，所以他会立马保存所有它的值。一个 "懒数组" 则是可以随时改变它的值。

Since we won't necessarily know when a new value has arrived in `a`, another key thing we need is to be able to listen to `b` to be notified when new values are made available. We could imagine a listener like this:

由于我们不一定要知道 `a` 什么时候添加了新的值，所以另一个关键就是我们需要有去监听 `b` 并在有新值的时候通知它的能力。我们可以想象下监听器是这样的：

```js
b.listen( function onValue(v){
	console.log( v );
} );
```

`b` is *reactive* in that it's set up to *react* to values as they come into `a`. There's an FP operation `map(..)` that describes how each value transfers from the origin `a` to the target `b`. Each discrete mapping operation is exactly how we modeled single-value operations with normal synchronous FP, but here we're spreading out the sourcing of values over time.

`b` 是反应性的，因为它被设置为当 `a` 有值添加时进行*反应*。有一个函数式编程的操作 `map(..)` 的作用是把数据源 `a` 里面的所有值转移到目标 `b` 里。<del>每次单独的映射操作都是我们使用普通的同步 FP进行单值模型操作，但是在这里我们将随着时间来展开原始的值</del>

**Note:** The term most commonly applied to these concepts is Functional Reactive Programming (FRP). I'm deliberately avoiding that term because there's some debate as to whether FP + Reactive genuinely constitutes FRP. We're not going to fully dive into all the implications of FRP here, so I'll just keep calling it reactive FP. Alternately, you could call it evented-FP if that feels less confusing.

**注意：** 最常用到这函数式编程些概念的术语是 Functional Reactive Programming (FRP)。我故意避开这个术语是因为一个有关于 FP + Reactive 是否真的构成FRP的辩论。我们不会全面深入了解FRP的所有含义，所以我会继续称之为 响应式函数式编程。或者，如果你不会感觉那么困惑，也可以称之为 事件机制函数式编程。

We can think of `a` as producing values and `b` as consuming them. So for readability, let's reorganize this snippet to separate the concerns into *producer* and *consumer* roles:

我们可以把 `a` 当作生成的值而 `b` 则是消费的值。所以为了可读性，我们得重新整理下这段代码，让问题归结于 *生产者* 和 *消费者*。

```js
// producer:

var a = new LazyArray();

setInterval( function everySecond(){
	a.push( Math.random() );
}, 1000 );


// **************************
// consumer:

var b = a.map( function double(v){
	return v * 2;
} );

b.listen( function onValue(v){
	console.log( v );
} );
```

`a` is the producer, which acts essentially like a stream of values. We can think of each value arriving in `a` as an *event*. The `map(..)` operation then triggers a corresponding event on `b`, which we `listen(..)` to so we can consume the new value.

`a` 是一个行为本质上很像数据流的生产者。我们可以把每个值赋给 `a` 当作一个*事件*。`map(..)` 操作会触发 `b` 上面的 `listen(..)` 事件来消费新的值。

The reason we separate the *producer* and *consumer* concerns is so that different parts of our application can be responsible for each concern. This code organization can drastically improve both code readability and maintenance.

我们分离*生产者* 和 *消费者*相关代码的原因是因为我们的应用程序的不同部分都都应该有各自的职责。这样的代码组织可以很大程度上提高代码的可读性和维护性。

### Declarative Time
### 声明式的时间

We're being very careful about how we introduce time into the discussion. Specifically, just as promises abstract time away from our concern for a single asynchronous operation, reactive FP abstracts (separates) time away from a series of values/operations.

我们非常谨慎地讨论如何介绍时间状态。具体来说，<del>正如 promise 把我们担心的时间状态从单个异步操作中抽离出来</del>，响应式函数式编程则是从一系列的值/操作中抽离（分割）了时间状态。

From the perspective of `a` (the producer), the only evident time  concern is our manual `setInterval(..)` loop. But that's only for demonstration purposes.

从 `a` （生产者）来说，唯一与时间相关的就是我们手动调用的 `setInterval(..)` 循环。但它只是为了达到某个目的。

Imagine `a` could actually be attached to some other event source, like the user's mouse clicks or keystrokes, websocket messages from a server, etc. In that scenario, `a` doesn't actually have to concern itself with time. It's merely a time-independent conduit for values, whenever they are ready.

想象下 `a` 可以被绑定上一些其他的事件源，比如说用户的鼠标点击事件和键盘按键事件，服务端来的 websocket 消息等。在这些情况下，`a` 没必要关注自己的时间状态。每当值准备好，它就只是一个与值连接的无时态管道。

From the perspective of `b` (the consumer), we do not know or care when/where the values in `a` come from. As a matter of fact, all the values could already be present. All we care about is that we want those values, whenever they are ready. Again, this is a time-independent (aka lazy) modeling of the `map(..)` transformation operation.

从 `b` （消费者）来说，我们不用知道或者关注 `a` 里面的值在何时何地来的。事实上，所有的值都已经存在。<del>我们只关注每当有值传过来的时候时，我们就能取到。或者说，这是 `map(..)` 转换操作生成的一个无时态（lazy）的模型。</del>

The *time* relationship between `a` and `b` is declarative, not imperative.

*时间*与`a` 和 `b` 之间的关系是声明式的，不是命令式的。

The value of organizing such operations-over-time this way may not feel particularly effective yet. Let's compare to how this same sort of functionality could have be expressed imperatively:

以 operations-over-time 这种方式来组织值可能不是很有效。让我们来对比下相同的功能如何用命令式来表示：

```js
// producer:

var a = {
	onValue(v){
		b.onValue( v );
	}
};

setInterval( function everySecond(){
	a.onValue( Math.random() );
}, 1000 );


// **************************
// consumer:

var b = {
	map(v){
		return v * 2;
	},
	onValue(v){
		v = this.map( v );
		console.log( v );
	}
};
```

It may seem rather subtle, but there's a important difference between this more-imperative version of the code and the previous more-declarative version, aside from just `b.onValue(..)` needing to call `this.map(..)` itself. In the former snippet, `b` pulls from `a`, but in the latter snippet, `a` pushes to `b`. In other words, compare `b = a.map(..)` to `b.onValue(v)`.

这看起来很微妙，但是这就是一个很重要的不同点存在于命令式版本的代码和之前声明式的版本，除了 `b.onValue(..)` 需要自己去调用 `this.map(..)` 之外。在之前的代码中， `b` 从 `a` 当中去拉取，但是在这个代码中，`a` 推送给 `b`。换句话说，把 `b = a.map(..)` 替换成 `b.onValue(v)`。

In the latter imperative snippet, it's not clear (readability wise) from the consumer's perspective where the `v` values are coming from. Moreover, the imperative hard coding of `b.onValue(..)` in the mix of producer `a`'s logic is a bit of a violation of separation-of-concerns. That can make it harder to reason about producer and consumer independently.

在上面的命令式代码中，以消费者的角度来说它并不清楚 `v` 从哪里来。此外命令式强硬的把代码 `b.onValue(..)` 夹杂在生产者 `a` 的逻辑里，这有点违反了 separation-of-concerns（职责分离？）原则。这将会让分离生产者和消费者变得困难。

By contrast, in the former snippet, `b = a.map(..)` declares that `b`'s values are seeded from `a`, and treats `a` as abstract event stream data source that we don't have to concern ourselves with at that moment. We *declare* that any value that comes from `a` into `b` will go through the `map(..)` operation as specified.

相比之下，在之前的代码中，`b = a.map(..)` 表示了 `b` 的值来源于 `a` ，对于如同抽象事件流的数据源 `a`，我们不需要关心。我们可以*确信*任何来自于 `a` 到 `b` 里的值都会通过 `map(..)` 操作。

### More Than Map
### 映射之外的东西

For convenience, we've illustrated this notion of pairing `a` and `b` together over time via a one-to-one `map(..)`ing. But many of our other FP operations could be modeled over time as well.

Consider:

<del>为了方便，我们已经说明过了这个概念：随着时间推移，通过不断的 `map(..)` 来绑定 `a` 和 `b`。但是我们有许多其他的函数式编程操作可以运行的很好。</del>

考虑下：

```js
var b = a.filter( function isOdd(v) {
	return v % 2 == 1;
} );

b.listen( function onlyOdds(v){
	console.log( "Odd:", v );
} );
```

Here, a value from `a` only comes into `b` if it passes the `isOdd(..)` predicate.

这里可以看到 `a` 的值肯定会通过 `isOdd(..)` 赋值给 `b`。

Even `reduce(..)` can be modeled over time:

即使是 `reduce(..)` 也可以持续的运行：

```js
var b = a.reduce( function sum(total,v){
	return total + v;
} );

b.listen( function runningTotal(v){
	console.log( "New current total:", v );
} );
```

Since we don't specify an `initialValue` to the `reduce(..)` call, neither the `sum(..)` reducer nor the `runningTotal(..)` event callback will be invoked until at least two values have come through from `a`.

因为我们调用 `reduce(..)` 是没有给具体 `initialValue` 的值，无论是 `sum(..)` 或者 `runningTotal(..)` 都会等到有 2 个来自 `a` 的参数时才会被调用。

This snippet implies that the reduction has a *memory* of sorts, in that each time a future value comes in, the `sum(..)` reducer will be invoked with whatever the previous `total` was as well as the new next value `v`.

这段代码暗示了在 reduction 里面有一个 *内存空间*， 每当有新的值进来的时候，`sum(..)` 才会带上第一个参数 `total` 和第二个参数 `v`被调用。

Other FP operations extended over time could even involve an internal buffer, like for example `unique(..)` keeping track of every value it's seen so far.

<del>其他的函数式编程操作会在内部作用域请求一个缓存区</del>，比如说 `unique(..)` 可以追踪每一个它访问过的值。

### Observables
### Observables

Hopefully by now you can see the importance of a reactive, evented, array-like data structure like the fictional `LazyArray` we've conjured. The good news is, this kind of data structure already exists, and it's called an observable.

希望现在你可以察觉到响应式，事件式，类数组结构的数据的重要性，就像我们虚构出来的 `LazyArray` 一样。值得高兴的是，这类的数据结构已经存在的了，它就叫 observable。

**Note:** Just to set some expectation: the following discussion is only a brief intro to the world of observables. This is a far more in-depth topic than we have space to fully explore. But if you've understood functional-light programming in this text, and now understood how asynchronous-time can be modeled via FP principles, observables should follow very naturally for your continued learning.

**注意：** 只是做些假设（希望）：接下来的讨论只是简要的介绍 observables。这是一个需要我们花充足的时间去探究的更深层次的话题。但是如果你理解本文中的轻量级函数式编程，并且知道如何通过函数式编程的原理来构建异步的话，那么接着学习 observables 将会变得顺心得手。

Observables have been implemented by a variety of userland libraries, most notably RxJS and Most. At the time of this writing, there's an in-progress proposal to add observables directly to JS, just like promises. For the sake of demonstration, we'll use RxJS-flavored Observables for these next examples.

现在已经有各种各样的 Observables 的库类， 最出名的是 RxJS 和 Most。在写这篇文章的时候，正好有一个直接向 JS 里添加 observables 的建议，就像 promise。为了演示，我们将用 RxJS 风格的 Observables 来完成下面的例子。

Here's our earlier reactive example, expressed with Observables instead of `LazyArray`:

这是我们一个较早的响应式的例子，但是用 Observables 来代替 `LazyArray`：

```js
// producer:

var a = new Rx.Subject();

setInterval( function everySecond(){
	a.next( Math.random() );
}, 1000 );


// **************************
// consumer:

var b = a.map( function double(v){
	return v * 2;
} );

b.subscribe( function onValue(v){
	console.log( v );
} );
```

In the RxJS universe, an Observer subscribes to an Observable. If you combine the functionality of an Observer and an Observable, you get a Subject. So, to keep our snippet simpler, we construct `a` as a Subject, so that we can call `next(..)` on it to push values (events) into its stream.

在 RxJS 中，一个 Observer 订阅一个 Observable。如果你把 Observer 和 Observable 的功能结合到一起，那就会得到一个 Subject。因此，为了保持代码的简洁，我们把 `a` 构建成一个 Subject，所以我们可以调用它的 `next(..)` 来添加值（事件）到他的数据流里。

If we want to keep the Observer and Observable separate:

如果我们要 Observer 和 Observable 保持分离：

```js
// producer:

var a = Rx.Observable.create( function onObserve(observer){
	setInterval( function everySecond(){
		observer.next( Math.random() );
	}, 1000 );
} );
```

In this snippet, `a` is the Observable, and unsurprisingly, the separate observer is called `observer`; it's able to "observe" some events (like our `setInterval(..)` loop); we use its `next(..)` method to send events to the `a` observable stream.

在这个代码里，`a` 是 Observable，毫无疑问，`observer` 就是独立的 observer，它可以去“观察”一些事件（比如我们的`setInterval(..)`循环），然后我们使用它的 `next(..)` 方法来发送一些事件到 observable `a` 的流里。

In addition to `map(..)`, RxJS defines well over a hundred operators that are invoked lazily as each new value comes in. Just like with arrays, each operator on an Observable returns a new Observable, meaning they are chainable. If an invocation of operator function determines a value should be passed along from the input Observable, it will be fired on the output Observable; otherwise it's discarded.

除了 `map(..)`，RxJS 还定义了超过 100 个可以在有新值添加时才触发的方法。就像数组一样。每个 Observable 的方法都会返回一个新的 Observable，意味着他们是链式的。如果一个方法被调用，则它的返回值应该由输入的 Observable 去返回，然后触发到输出的 Observable里，否则抛弃。

Example of a declarative observable chain:

一个链式的声明式 observable 的例子：

```js
var b =
	a
	.filter( v => v % 2 == 1 )		// only odd numbers
	.distinctUntilChanged()			// only consecutive-distinct
	.throttle( 100 )				// slow it down a bit
	.map( v = v * 2 );				// double them

b.subscribe( function onValue(v){
	console.log( "Next:", v );
} );
```

**Note:** It's not necessary to assign the observable to `b` and then call `b.subscribe(..)` separately from the chain; that's only done to reinforce that each operator returns a new observable from the previous one. Often, the `subscribe(..)` call is just the final method in the chain.

**注意：** 这里的链式写法不是一定要把 observable 赋值给 `b` 和调用 `b.subscribe(..)` 分开写，这样做只是为了让每个方法都会得到一个新的返回值。通常，`subscribe(..)` 方法都会在链式写法的最后被调用。

## Summary
## 总结

This book has detailed a wide variety of FP operations that take a single value (or an immediate list of values) and transform them into another value/values.

这本书详细的介绍了各种各样的函数式编程操作，<del>例如：获取单个值然后把他转换到另一个值里。</del>

For operations that will be proceed over time, all of these foundational FP principles can be applied time-independently. Exactly like promises model single future values, we can model eager lists of values instead as lazy observable (event) streams of values that may come in one-at-a-time.

对于那些有时态的操作，所有的函数式编程基础原则都可以应用到与时间无关的方面。就像单一的未知值 promise 模型，我们可以创建一个 eager 列表的值来代替像 lazy  observable（事件）流的值。

A `map(..)` on an array runs its mapping function once for each value currently in the array, putting all the mapped values in the outcome array. A `map(..)` on an observable runs its mapping function once for each value, whenever it comes in, and pushes all the mapped values to the output observable.

数组的 `map(..)` 方法运行是会映射一次当前数组里的所有的值，然后放到返回的数组里。observable 的数组则是映射一次所有的值，无论值什么时候进来，都会映射值到返回的 observable 里。

In other words, if an array is an eager data structure for FP operations, an observable is its lazy over-time counterpart.

或者说，如果数组对函数式编程操作是一个 eager 的数据结构，那么 observable 相当于持续的 lazy。